
{\tt ocp-build} can be used to compile simple OCaml projects.
The tool uses simple configuration files to describe the
packages that need to be compiled, and the dependencies between
them.

Compared to other OCaml building tools, it provides the following
particularities:
\begin{itemize}
\item {\tt ocp-build} supports complete parallel builds. Its improved
  understanding of OCaml compilation constraints avoids traditionnal
  problems, arising from conflicts while compiling interfaces.
\item {\tt ocp-build} configuration files provide a simple and concise
  way to handle the complexity of OCaml projects.
\item {\tt ocp-build} supports complex compilation rules, such as
  per-file options, packing and C stubs files.
\item {\tt ocp-build} can use either a set of attributes or a digest
  of the content of a file to detect files' modifications to decide
  which files should be rebuilt.
\end{itemize}

\section{Environment Variables}

\ocpbuild{} uses the following environment variables :
\begin{description}
\item[HOME] : the user directory (``.'' if not defined)
\item[OCP\_HOME] : ocp-build configuration directory (``\$HOME/.ocp''
  if not defined)
\item[PATH] : the path of directories containing commands (separated
  by ``:'' on Unix, ``;'' on Windows)
\item[TERM] : if defined, characters are escaped (also on Windows)
\item[OCPBUILD\_VERBOSITY] : verbosity before the -v option is parsed.
\item[OCP\_DEBUG\_MODULES] : which modules to debug (need more info...)
\item[OCAMLLIB] : not directly used by \ocpbuild{}, but used by OCaml,
  from which \ocpbuild{} computes its own configuration.
\end{description}

\section{Configuration Files}

 {\tt ocp-build} uses a set of files to describe a project:
\begin{itemize}
\item Each package (or set of packages) should be described in a file
  with an {\tt .ocp} extension. When {\tt ocp-build} is run with the
  {\tt -scan} option, it scans the directory to find all such
  configuration files, and adds them to the project.
\end{itemize}

\section{Compilation Layout}

{\tt ocp-build} generates files both in the source directories and in
a special {\tt \_obuild} directory, depending on the nature of the
files:
\begin{itemize}
\item Temporary source files and compilation garbage are stored in the
  source directories. This set includes implementation and interfaces
  files generated by {\tt ocamllex} and {\tt ocamlyacc}, and other
  special files such as {\tt .annot} files.
\item Binary object files are stored in the {\tt \_obuild} directory,
  where a sub-directory is created for each package.
\end{itemize}

\section{Format of the package description files ({\tt .ocp})}

\subsection{Description of Simple Packages}

A simple package description looks like this:

\begin{verbatim}
begin library "ocplib-system"
  files = [ "file.ml" "process.ml" ]
  requires = [ "unix" ]
end
\end{verbatim}

This description explains to {\tt ocp-build} that a library {\tt
  ocplib-system} should be built from source files {\tt file.ml} and
{\tt process.ml} (and possibly {\tt file.mli} and {\tt process.mli}),
and that this library depends on the {\tt unix} library to be built.

Another simple description is:

\begin{verbatim}
begin program "file-checker"
  files = [ "checkFiles.ml" "checkMain.ml" ]
  requires = [ "ocplib-system" ]
end
\end{verbatim}

This description tells {\tt ocp-build} that it should build an
executable {\tt file-checker} from the provided source files, and with
a dependency towards {\tt ocplib-system}. {\tt ocp-build} will
automatically add the dependency towards {\tt unix} required by {\tt
  ocplib-system}.

\subsection{OCaml Configuration}

The following variables are automatically defined by
\ocpbuild{} from OCaml configuration:
\begin{description}
\item[ocaml\_major\_version]
\item[ocaml\_minor\_version]
\item[ocaml\_point\_version]
\end{description}

\subsection{OCaml options}

\subsubsection{Per-package options}

\begin{description}
\item[dirname(string)] The directory where the package files are located.
\item[generated(bool)] If true, the package is already installed
\item[has\_byte(bool)]
\item[has\_asm(bool)]
\end{description}

\subsubsection{Per-file options}


\begin{description}
\item[ml(bool)] The file is an implementation source (.ml file)
\item[mli(bool)] The file is an interface source (.mli file)
\item[cflags(list)] Options to be passed to the C compiler
\item[ccopt(list)] ???
\item[nopervasives(bool)]
\item[nodeps(list)] A list of false dependencies
\item[nocmxdeps(list)] A list of false dependencies for native code
\item[bytelink(list)]
\item[bytecomp(list)]
\item[asmlink(list)]
\item[asmcomp(list)]
\item[dep(list)]
\item[rule\_sources(list)]
\item[pp(list)] ???
\item[pp\_requires(list)] ???
\item[sort(bool)]
\end{description}


\subsection{Advanced options}

\subsubsection{Per-file options}

Options can be specified on a per-file basis:

\begin{verbatim}
begin library "ocplib-fast"
  files = [
    "fastHashtbl.ml" (asmcomp = [ "-inline"; "30" ])
    "fastString.ml"
  ]
end
\end{verbatim}

They can also be specified for a group of files:

\begin{verbatim}
begin library "ocplib-fast"
  files = [
    begin  (asmcomp = [ "-inline"; "30" ])
    "fastHashtbl.ml"
    "fastMap.ml"
    end
    "fastString.ml"
  ]
end
\end{verbatim}


\section{Description of Specific Rules}

In the following descriptions, variables noted as {\em \$var} refers
to the variable in the environment of the rule, as specified directly
in the {\tt .ocp} file or in the object given for the package in
the {\tt .ocp2} file.

\subsection{Building a {\tt .cmxa} Library}

The generic rule to build a {\tt .cmxa} is the following:
\begin{itemize}
\item Targets: (the default value of {\em \$archive} is the name of the
  library,{\em library}.
\begin{itemize}
\item {\tt \_obuild(lib)/{\em \$archive}.cmxa}
\item {\tt \_obuild(lib)/{\em \$archive}.a}
\end{itemize}
\item Dependencies:
\begin{itemize}
\item From the package: {\tt cmx\_files}, {\tt o\_files},
  {\tt cmi\_files}
\item Variables: {\tt\em \$ocamlopt\_deps},  {\tt\em \$link\_deps},
      {\tt\em \$asmlink\_deps}
\end{itemize}
\item Commands:
  \begin{itemize}
    \item Directory: the targets are first built in the sources, then
      moved to the destination directory;
    \item Compilation: {\tt
      {\em \$ocamlopt} asmlinkflags "-a" "-o" temp\_cmxa
      "-cclib" {\em \$cclib} (if {\em \$force\_link} then "-linkall")
      includes(lib) cmxa\_requires(lib)  cmx\_files
    }
    \item {\tt asmlinkflags} is:
      {\tt (if {\em \$debug} then "-g")\\
        (if {\em \$asmdebug} then "-g")\\
        (if {\em \$nopervasives} then "-nopervasives")\\
        {\em \$asmlink}}
  \end{itemize} 
\end{itemize}

\subsection{Building a {\tt .cmxs} Plugin}

A {\tt .cmxs} plugin is built by default for every library, unless
{\tt\em \$cmxs\_plugin} is {\tt false}. Since it is not clear that
OCaml can build in parallel the native library and the native plugin,
they are actually built consecutively in the same rule.

Here are the parameters that are added to the {\tt .cmxa} rule:
\begin{itemize}
\item Targets:
\begin{itemize}
\item {\tt \_obuild(lib)/{\em \$archive}.cmxs}
\end{itemize}
\item Dependencies:
\begin{itemize}
\item From the package: {\tt cmx\_files}, {\tt o\_files},
  {\tt cmi\_files} and {\tt stubs\_files}
\item Variables: {\tt\em \$ocamlopt\_deps},  {\tt\em \$link\_deps},
      {\tt\em \$asmlink\_deps}, {\tt\em \$asmlink\_libs}
\end{itemize}
\item Commands:
  \begin{itemize}
    \item Directory: the targets are first built in the sources, then
      moved to the destination directory;
    \item Compilation: {\tt
      {\em \$ocamlopt} asmlinkflags "-shared"
      "-I" \_obuild(lib) "-o" temp\_cmxa
      "-cclib" {\em \$cclib} (if {\em \$force\_link} then "-linkall")
      includes(lib) cmxa\_requires(lib) 
      \$asmlink\_libs cmx\_files
    }
    \item same {\tt asmlinkflags} as in the {\tt .cmxa} rule
  \end{itemize} 
\end{itemize}

Notice the additionnal {\tt\em \$asmlink\_libs} that can be added in a
{\tt .cmxs} file, even if not part of the {\tt requires} (as for
native programs).

%%% Local Variables:
%%% recompile: "pdflatex user-manual"
%%% End:
